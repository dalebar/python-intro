<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Python Intro</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="themes/prism.css"/>
  </head>
  <body>
    <nav id="navbar">
      <header>Introduction to Python</header>
      <ul>
        <li><a class="nav-link" href="#Introduction">Introduction</a></li>
        <li><a class="nav-link" href="#Python_Variables">Python Variables</a></li>
        <li><a class="nav-link" href="#Functions">Functions</a></li>
        <li><a class="nav-link" href="#Lists">Lists</a></li>
        <li><a class="nav-link" href="#Dictionaries">Dictionaries</a></li>
        <li><a class="nav-link" href="#Branching_and_Logic">Branching and Logic</a></li>
        <li><a class="nav-link" href="#Iteration">Iteration</a></li>
        <li><a class="nav-link" href="#Exercises">Exercises</a></li>
        <li><a class="nav-link" href="#Reference">Reference</a></li>
      </ul>  
    </nav>
    <main id="main-doc">
      <section class="main-section" id="Introduction">
        <header>Introduction</header>
        <article>
          <h2>What is programming ?</h2>
          <p>
          Computers require precise instructions in order to perform actions or complete tasks. Humans write programs or software that can then be turned into instructions that computers can understand in order to perform tasks.
          </p>
          <p>
          Programming languages provide a set of rules for writing out instructions that can be used by humans but that will ultimately be broken down into precise instructions for a machine.
          </p>
          <h2>Computer programs</h2>
          <p>
          A computer program is a set of instructions written for machines to execute. Machines themselves only deal with binary data at a fundamental level. Binary data means bits (short for binary digits which are either 1s or 0s.) This data is used to carry out tasks by the computer. We could, in theory, write code which is just a series of bits. However, it is incredibly difficult for humans to reason about code at this level.
          </p>
          <p>
          A higher level programming language provides greater abstraction away from machine language so that humans can write instructions that will ultimately be executed by a computer. <b>Higher-level languages</b> are designed to make writing instructions far simpler: eventually these programs will be converted into machine language so the machine can execute them.
          </p>
          <h2>Python</h2>
          <p>
          Python is a <b>high-level programming language</b> and one of the most popular programming languages in the world. It is used for a wide variety of tasks, including data analysis, scientific computing and managing Web page servers. Well-known software companies, such as Netflix, Spotify, Facebook, and Google, use Python to create some or all of their products.
          </p>
        </article>
        <article>
          <h1>Data and functions</h1>
          <p>A fundamental concept in computer programming and within Python are the notions of data and functions. Data could be any piece of information - numbers, images or text. A programming language will usually have some basic data types built-in to its code already.</p>
          <p>One of these <b>native</b> (built-in) data types in Python is a <b>string</b>. A string is a piece of text enclosed inside quotation marks, written like this:</p>
          <pre><code class="language-python">'hello northcoders'</code></pre>
          <p>A <b>function</b> is a set of instructions within a program that can be used to perform an action. A large part of programming involves writing functions that will carry out meaningful tasks with our data types.</p>
          <p>Functions are one of the fundamental units of Python. A function will often be designed to take inputs, carry out some tasks and provide an output.</p>
          <p>Think of a function called <code class="snippet">add</code>. This function will take in number inputs (some data), and then produce an output. So if we passed in the input values of <code class="snippet">10</code> and <code class="snippet">32</code> into our add function, we could expect it to output a value of <code class="snippet">42</code>. It is our task as developers to implement or build functions that will carry out tasks like the one previously mentioned.</p>
          <h2>Our first program</h2>
          <h3>"hello northcoders"</h3>
          <p>We can now think about writing our first Python program using some data and a function. In order to save time and make it easy for developers to write software, programming languages will often come with pre-made built-in functions or tools in order to carry out certain kinds of important work.</p>
          <p><code class="snippet">print</code> is one such tool or function and is very commonly used in Python. It is an in-built function we can use in order to print information or data to our console.</p>
          <p>Once we have written the function, we can update our code in order to actually <b>use</b> the function. Unless we actually write the code to say we are using the function, then nothing will happen.</p>
          <p>In order to use <code class="snippet">print</code> we must then <b>call</b> the function. <b>Calling</b> or <b>invoking</b> a function means running the function so its instructions are <b>executed</b>, like below:</p>
          <pre><code class="snippet">print('hello northcoders!')</code></pre>
          <p>The example above consists of 3 different parts:</p>
          <ol>
            <li>
              <pre><code class="language-python">print</code></pre>
              <ul>
                <li>the name of a function, in this case <code class="snippet">print</code></li>
              </ul>
            </li>
            <li>
              <pre><code class="language-python">print()</code></pre>
              <ul>
                <li>parentheses. This notation after the name of a functions means we are <b>calling the function</b></li>
              </ul>
            </li>
            <li>
              <pre><code class="language-python">print('hello northcoders')</code></pre>
              <ul>
                <li>an <b>input</b>, which is the string of text: <code class="snippet">"hello northcoders"</code></li>
              </ul>
            </li>
          </ol>
          <h3>Strings</h3>
          <p>The input into our function <code class="snippet">print</code> was the following piece of data: <code class="snippet">"hello northcoders"</code>.</p>
          <p>Any characters enclosed inside quotation marks <code class="snippet">"</code> or <code class="snippet">'</code> are known as a string. We can think of this as a type of data used for storing text information.</p>
          <pre><code class="language-python">'hello northcoders'</code></pre>
          <h3>Comments</h3>
          <p>Comments are parts of a program that will be ignored by the computer. Comments in Python are denoted by # starting on a line like in the example below:</p>
          <pre><code class="language-python">print('hello northcoders')
          </code><br><code class="language-python">
          # this will print the message 'hello northcoders' to the screen</code></pre>
        </article>
        <article>
          <h1>The Python REPL</h1>
          <p>Python offers an easy way to try out code one command at a time. The <b>Read-Evaluate-Print-Loop</b> (or <b>REPL</b>) can be started just by running the <code>python</code> command. Then we can run individual commands at the prompt.</p>
          <p>Each command that we run will be automatically printed to the console.</p>
          <p>Open a terminal and enter the python command to open the REPL</p>
          <pre><code class="language-python">python</code></pre>
          <p>Once you've opened it, try a simple command. Type the expression below and press enter to run the code. (You don't need to type the <code class="snippet">>>></code>, just the <code class="snippet">5 + 5</code>)</p>
          <pre><code class="language-python">>>> 5 + 5</code></pre>
          <p>This should be evaluated and <code class="snippet">10</code> printed to your terminal.</p>
          <p>We can run Python commands one at a time like this. This is very useful for trying things out quickly or running simple commands as and when you need them.</p>
          <p>Run the command below to try out the program from the previous section.</p>
          <pre><code class="language-python">>>> print('hello northcoders')</code></pre>
          <p>To exit the <code class="snippet">REPL</code> and return to your normal terminal, you can either run the in-built function <code class="snippet">exit()</code> or use the <code class="snippet">ctrl + d</code> keyboard shortcut.</p>
        </article>
        <article>
          <h1>Running Python scripts</h1>
          <p>As well as running code directly in the <code class="snippet">REPL</code>, we can create Python files that can be edited and re-used.</p>
          <p>We are going to use a file called <code class="snippet">example.py</code> and in it write some Python code.</p>
          <p>Make a new directory and open it with <code class="snippet">VSCode</code>. Inside of that directory, create a new file called <code class="snippet">example.py</code>.</p>
          <p>Edit this file so that it contains the same print statement as in the previous example, make sure you save the file once you're done!</p>
          <pre><code class="language-python">print('hello northcoders')</code></pre>
          <p>We can now use the <code class="snippet">python</code> command followed by the file we want to run, which runs the Python <b>interpreter</b>, in order to run this piece of code:</p>
          <pre><code class="language-python">$ python example.py</code></pre>
          <p>The greeting should be printed to the terminal. If you get an error about not being able to open the file, make sure that your terminal is in the right directory. Use the <code class="snippet">ls</code>, <code class="snippet">cd</code> and <code class="snippet">pwd</code> commands to make sure that your terminal is in the same directory as the <code class="snippet">example.py</code> file.</p>
        </article>
      </section>
      <section class="main-section" id="Python_Variables">
        <header>Python Variables</header>
        <article>
          <h1>Storing data</h1>
          <p>Python has five basic data types. These are:</p>
          <ul>
            <li><b>Strings</b> - including all kinds of characters that you can write: letters, numbers, punctuation, and symbols like emojis</li>
            <li><b>Integers</b> - positive or negative whole numbers, including zero</li>
            <li><b>Floating point</b> numbers - what you might think of as "decimals", numbers expressing fractional quantities. (The word "decimal" is not used in this context in computing because all numbers - including fractional quantities - are stored in <i>binary</i> rather than decimal format)</li>
            <li><b>Booleans</b> - <code class="snippet">True</code> / <code class="snippet">False</code></li>
            <li><b>None</b> - empty data</li>
          </ul>
          <p>There are many other data types (in fact, potentially an infinite number because you can make your own), but these are the basics.</p>
          <p>But, first things first, what exactly is a data "type" and why do we need them? To answer this, we need to think about how computers store data in memory.</p>
          <p>Probably the simplest kind of data is a Boolean, which just means a value that is either <code class="snippet">True</code> or <code class="snippet">False</code>. All data stored on the RAM chip on your computer is stored in bits. A bit is just a tiny switch on a memory chip that is either on or off.</p>
          <ul>
            <li><code class="snippet">True</code> is represented by 1 ("on").</li>
            <li><code class="snippet">False</code> is represented by 0 ("off").</li>
          </ul>
          <p>What about storing an integer? Well, it depends on how big a number you might want to store. A common choice is that you might use 32 bits to store an integer. That means you could store a number up to 2,147,483,647 which is 2<sup>31</sup> - 1. In binary, that is written:</p>
          <blockquote><p>1111111111111111111111111111111<sub>2</sub></p></blockquote>
          <p>If you can be bothered to count, you will find that there are 31 ones. The extra bit is used to signify whether the number is positive or negative.</p>
          <p>We also need some way to tell the programming language how to interpret this data. For example, how can the computer tell when we store a <code class="snippet">1</code> whether we mean the number 1 or the boolean value <code class="snippet">True</code>?</p>
          <p>To summarise then, even for basic types of data, we need to be able to:</p>
          <ul>
            <li>allocate the correct amount of memory</li>
            <li>have some way of figuring out how to interpret the data.
            </li>
          </ul>  
        </article>
        <article>
          <h1>Python Objects</h1>
          <p>For each data type, Python needs to be able to:</p>
          <ul>
            <li>allocate the correct amount of memory</li>
            <li>have some way of figuring out how to interpret the data.
            </li>
          </ul> 
          <p>Although Python performs both these tasks automatically, storage is complicated by the fact that Python associates lots of extra properties and added pieces of code (called "methods") along with even basic data types. Consider a simple piece of text like "hello". In principle, each letter can be stored with just one byte (8 bits) of memory, so this should only take five bytes of RAM. However, in Python, it takes up much more space.</p>
          <p>To see this, in the Python REPL, type:</p>
          <pre><code class="language-python">dir('hello')</code></pre>
          <p>You will see quite a complicated output, something like this:</p>
          <pre><code class="language-python">['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']</code></pre>
          <p>The <code class="snippet">dir</code> command lists the attributes or properties of any piece of data in Python. All of these items are pieces of data or code that Python has added to our little piece of "hello" text to make it easier to work with. For example, at the next prompt, we could make use of the <code class="language-python">upper</code> method, which is for converting text to upper case:</p>
          <pre><code class="language-python">'hello'.upper()</code></pre>
          <p>This should output:</p>
          <pre><code class="language-python">'HELLO'</code></pre>
          <p>Adding in handy little tools like this is one of the reasons Python is easy to use, but conceptually it can be quite tricky to understand sometimes, and it does make Python slower than other languages like C. Enriched data types that include this kind of added feature are usually called "objects". A very important fact is that:</p>
          <blockquote><p>Everything in Python is an object.</p></blockquote>
          <p>In the coming weeks, we will learn how to understand and manipulate the features of Python objects.</p>
          <p>Observe that the Python interpreter has done something pretty clever here - it has realised that "hello" is a piece of text and provided it with useful added features appropriate for that type of data. Instead, if we examine how Python stores a number,</p>
          <pre><code class="language-python">dir(5)</code></pre>
          <p>we will get a very different set of properties. That's because Python can do <b>type inference</b> - it can determine from an input what the data type is. Then, it will build the correct object with the right amount of memory and the appropriate added features.</p>
          <p>If you ever encounter some data in Python and you are unsure of its type, there is a handy command to find it out - <code class="snippet">type</code>. Try these examples at the Python prompt:</p>
          <pre><code class="language-python">type('hello') # [class 'str'] (i.e. a string)
          </code><code class="language-python">
            type(7) # [class 'int']
            </code><code class="language-python">
            type(False) # [class 'bool']
            </code><code class="language-python">
            type(3.14159) # [class 'float']
            </code><code class="language-python">
            type(None) # [class 'NoneType']</code></pre>
          <p>Even though the <code class="snippet">None</code> keyword literally signifies a complete absence of data, it is an object with properties in Python - try <code class="snippet">dir(None)</code>.</p>
          <p>So to summarise, Python considers every piece of data to have a <i>type</i>. This is information that is associated with the data that tells Python:</p>
          <ul>
            <li>How much memory is needed to store it</li>
            <li>How to interpret the raw bits comprising the data</li>
            <li>What added features should come with this data
            </li>
          </ul>
        </article>
        <article>
          <h1>Variable declarations</h1>
          <blockquote><p>A variable is used to store a piece of data or information.</p></blockquote>
          <p>So far, we have just been typing whatever data we need directly into the Python interpreter. This gets tedious, and of course, we want to be able to store data to use later. Some data needs to be stored <i>persistently</i>, meaning that it can be retrieved repeatedly, perhaps by different computers. We use tools like hard drives, SSDs and databases to keep such data. However, in programming, we often need to store pieces of data temporarily (in the computer's memory) while we process it. That's where variables come in.</p>
          <p>In Python, to assign a variable, we just need to make up a name for the variable and use the <code class="snippet">=</code> symbol to assign it to a value. For example, type the following:</p>
          <pre><code class="language-python">greeting = 'hello'</code></pre>
          <p>Apparently, nothing happens, but behind the scenes, lots is going on. This short statement means:</p>
          <ol>
            <li>Get the piece of data "hello" and figure out its data type.</li>
            <li>Ask the operating system of the computer for a chunk of memory big enough to hold an object for the data and all the added features.</li>
            <li>Put the data object in the memory at the location specified by the operating system.</li>
            <li>Remember the memory location of the data and label it with the name "greeting" so that the user doesn't have to use a complicated memory address.
            </li>
          </ol>
          <p>Now, this name can be used to retrieve the data:</p>
          <pre><code class="language-python">print(greeting)</code></pre>
          <p>If you want to see exactly where the data is stored, type:</p>
          <pre><code class="language-python">id(greeting)</code></pre>
          <p>For me, the output from this command was a number: <code class="snippet">4347887728</code>. You will likely see something different, depending on your machine. In this case, my laptop responded to Python's request for memory by providing a section of memory starting at location 4347887728 in the RAM chip.</p>
          <p>So the <code class="snippet">print(greeting)</code> command is just shorthand for:</p>
          <pre><code class="language-python">print the object stored at memory location 4347887728</code></pre>
          <p>We could, if we needed to, access our "hello" data by using this memory address but (a) we don't need to, (b) it's a pain and (c) it's a bad idea in almost all circumstances. The purpose of the variable is to make it easy, reliable and straightforward to get the data we need and use it as we want.</p>
          <p>The name "variable" arises because we can reuse the name for different pieces of data. For example, we can reassign the <code class="snippet">greeting</code> variable to a different value:</p>
          <pre><code class="language-python">greeting = 'Howdy'</code><br>
            <code class="language-python">
            print(greeting) # outputs Howdy</code></pre>
          <p>If you use the <code class="snippet">id()</code> function, you should find that this new value is at a different memory location. We've just changed the place in memory that <code class="snippet">greeting</code> refers to. In the background, Python will quietly get rid of the "hello" text that we stored at the previous location so that the memory is available to be used again. This process is called "garbage collection".</p>
          <p>Some computing languages are <b>statically typed</b>, meaning that when you assign a variable you fix what type it is. So, for example, in Java, we could declare our greeting like this:</p>
          <pre><code class="language-python">String greeting = "hello"</code></pre>
          <p>The <code class="snippet">String</code> keyword determines the variable type - Java does not do type inference. However, once that is set, it can't be changed. By contrast, Python is <b>dynamically typed</b>. It's perfectly possible to change the variable's data type:</p>
          <pre><code class="language-python">greeting = 752</code></pre>
          <p>Python will reassess what the <code class="snippet">greeting</code> variable is for, changing not only its memory address but also the type of object it stores there. If you use the <code class="snippet">type</code> or <code class="snippet">dir</code> commands, you will see that <code class="snippet">greeting</code> is now an integer.</p>
        </article>
        <article>
          <h1>Constants</h1>
          <p>Python is <b>dynamically typed</b> meaning that variables can hold any data type and we can change that type as we wish.</p>
          <p>This feature of being able to change the assigned value of a variable is really useful in most circumstances, but there are some situations where we want to say something like, "Store this piece of data with this variable name and make it unchangeable throughout the life of the program". An example might be storing a web address, for example. Such variables are called <b>constants</b> and many languages provide support for enforcing constant values.</p>
          <p>Python does <i>not</i> support this feature. All variables can be reassigned to different values. However, there is a very strong convention that values that are intended to be constant should be written in capitals. So for example, we could write:</p>
          <pre><code class="language-python">WEBSITE_URL = 'https://www.northcoders.com'</code></pre>
          <p>In a Python program, the capitals would indicate to another developer that <code class="snippet">WEBSITE_URL</code> should not be reassigned. However, nothing would prevent this - it would be syntactically valid to later write:</p>
          <pre><code class="language-python">WEBSITE_URL = 'https://www.google.com'</code></pre>
          <p>But it would be <i>very naughty</i>.</p>
          <p>Another very strong Python convention is the use of <b>snake_case</b> for the naming of most variables. Many other languages use a <b>camelCase</b> convention, but (as we will see in the course), conventional Python uses variable names like <code class="snippet">customer_name</code> or <code class="snippet">order_number</code> - i.e. connect separate words with an underscore.</p>
        </article>
        <article>
          <h1>Exercises</h1>
          <p>To practise making variables, the next step is to fork and clone a repo so that you can complete some exercises on this and future topics.</p>
          <p>Follow the link to this GitHub repo: <a href="https://github.com/dalebar/python-practice">https://github.com/dalebar/python-practice</a> and follow the instructions in the README to get set up.</p>
          <p>Once you have the repo set up and cloned, complete the exercises in <code class="snippet">01_variables</code>.</p>
          <p>This is the only file you need to complete for now. The others will follow the relevant sections on this platform.</p>
        </article>
        <article>
          <h1>Summary</h1>
          <p>Make sure that you know and understand the following key points about storing data in Python:</p>
          <ul>
            <li>Python data is always stored as an <b>object</b> - data plus added features that help users and the Python interpreter interact with the data.</li>
            <li>The data <b>type</b> is information describing the data object and how much memory it requires.</li>
            <li>Python performs <b>type inference</b> - it figures out exactly what type of object the data should be stored as.</li>
            <li><b>Variables</b> allow us to save and retrieve data from memory without needing to know the exact memory location.</li>
            <li>Variables can be reassigned to different values...</li>
            <li>... even values that are different types. Python does <b>dynamic typing.</b></li>
            <li>The <code class="snippet">dir</code> and <code class="snippet">type</code> commands allow us to investigate the properties of data stored in Python.</li>
            <li>Variable names in CAPITALS are conventionally reserved for data whose values should never be changed.</li>
            <li>Most variable names consisting of more than one word should be written in <b>snake_case</b>.
            </li>
          </ul>
        </article>
      </section>
      <section class="main-section" id="Functions">
        <header>Functions</header>
        <article>
          <h1>What is a Function?</h1>
          <p>Here's a useful trick - Python <a href="https://speedsheet.io/s/python#d2zE">f-strings</a> allow us to manipulate different pieces of information into a single string.</p>
          <p>So, for example, we can do the following:</p>
          <pre><code class="language-python">greeting = 'Hello' # declaring a variable 
          </code><code class="language-python">
          print(f'{greeting},  Joe!') # prints Hello, Joe!</code></pre>
          <p>We joined the <code class="snippet">greeting</code> string to some punctuation (a comma and a space), then a name and then an exclamation mark. This is fun! We can do it again with a different name:</p>
          <pre><code class="language-python">print(f'{greeting}, Paul!')</code></pre>
          <p>Fantastic! Let's do it again:</p>
          <pre><code class="language-python">print(f'{greeting}, Vel!')</code></pre>
          <p>OK, this is starting to get a <i>teeny</i> bit tedious. We are doing pretty much the same thing over and over, changing only the name. It would be much better if we had a <i>reusable</i> chunk of code that we could run easily, providing only the new name that we want the greeting to address.</p>
          <p>That's where functions come in. There are some very specific details about defining a function that we will avoid here, but let's just think of it as a reusable piece of code that can (if necessary) process any data it is given.</p>
          <p>In Python, we can <b>declare</b> a function called <code class="snippet">cheerful_greeter</code> like this:</p>
          <pre><code class="language-python">def cheerful_greeter(name):
          </code><code class="language-python indent">
          salutation = 'Hello'
          </code><code class="language-python indent">
          print(f'{salutation}, {name}!)</code></pre>
          <blockquote><p>Note the usual indentation for the function definition. Note also the conventional use of <b>snake_case</b> to name the function.</p></blockquote>
          <p>In itself, this code does nothing except define a variable called <code class="snippet">cheerful_greeter</code> and assign it to a very specific type of object called a <code class="snippet">function</code>. If we type,</p>
          <pre><code class="language-python">cheerful_greeter</code></pre>
          <p>the Python interpreter will output something like:</p>
          <pre><code class="language-python">function cheerful_greeter at 0x1011c4180</code></pre>
          <p>This just tells me that there is some sort of function object at the given memory location. As with any other object, I can see what attributes it has:</p>
          <pre><code class="language-python">dir(cheerful_greeter)</code></pre>
          <p>... although the output doesn't tell us very much.</p>
          <p>The real magic is that we can <b>invoke</b> or <b>call</b> this function. Our function declaration included a <b>parameter</b> called <code class="snippet">name</code>, which means that our function must be called with a single piece of data. We can pass any value we like, as many times as we like:</p>
          <pre><code class="language-python">cheerful_greeter('Harry') # cheerfully greets Harry</code></pre>
          <p>Our function is infinitely reusable:</p>
          <pre><code class="language-python">cheerful_greeter('Spike')
          </code><code class="language-python">
          cheerful_greeter('Peter')</code></pre>
        </article>
        <article>
          <h1>Parameters and Arguments</h1>
          <p>The variable expected by the function call - <code class="snippet">name</code> - is called a <b>parameter</b>. The specific value we pass to the function, e.g. "Harry", is called an <b>argument</b>.</p>
          <p>The <code class="snippet">cheerful_greeter</code> function has one parameter. If we pass in more (or fewer), we get an error as soon as we call the function:</p>
          <pre><code class="language-python">cheerful_greeter('Mickey', 'Donald') # TypeError: cheerful_greeter() takes 1 positional argument but 2 were given
          </code><br><code class="language-python">
          cheerful_greeter() # TypeError: cheerful_greeter() missing 1 required positional argument: 'name'</code></pre>
          <p>Some programming languages require the developer to specify what type the parameter should be. Python provides some support for specifying the intended input (in this case, we intend that the parameter should be a string), but does not enforce anything. So, these examples "work", even though probably not as we intended:</p>
          <pre><code class="language-python">cheerful_greeter(['I', 'like', 'old', 'cartoons']) # this argument is a list, we'll find out more about these soon
          </code><code class="language-python">
            cheerful_greeter(7)
          </code><code class="language-python">
            cheerful_greeter(7.5)
          </code><code class="language-python">
            cheerful_greeter(False)</code></pre>
          <p>We'll see various ways to deal with this kind of unexpected behaviour later.</p>
          <p>Note that functions don't need to take any parameters at all. This is a perfectly good function:</p>
          <pre><code class="language-python">def hello_world():
          </code><code class="language-python indent">
            print('Hello, World!')</code></pre>
          <p>You do need to include empty brackets when calling it, though:</p>
          <pre><code class="language-python">hello_world() # Hello, World!</code></pre>
        </article>
        <article>
          <h1>Function Scope</h1>
          <p>It's important to understand that what goes on inside a function is in some sense "boxed off" from the rest of our code. Consider our original code snippet:</p>
          <pre><code class="language-python">greeting = 'Hello' 
          </code><code class="language-python">
            print(f'{greeting},  Joe!')</code></pre>
          <p>If I execute this, I get the required result, and I also have access to the <code class="snippet">greeting</code> variable:</p>
          <pre><code class="language-python">greeting # outputs Hello</code></pre>
          <p>So the <code class="snippet">greeting</code> variable exists and is accessible in our session.</p>
          <p>Within the code of our <code class="snippet">cheerful_greeter</code>, there is a different variable, <code class="snippet">salutation</code>. If we try to access it, we get an error:</p>
          <pre><code class="language-python">salutation # NameError: name 'salutation' is not defined</code></pre>
          <p>Likewise, the value of the <code class="snippet">name</code> parameter is not available:</p>
          <pre><code class="language-python">name # NameError: name 'name' is not defined.</code></pre>
          <p>Code executing within the function has its own segregated area of memory. This segregation is called the scope of the function, and we will discuss it in much more detail during the course. For now, you just need to understand that the internal workings of functions are designed to be separated from the rest of the code. We care about the name of the function (so it can be called), what arguments we pass in, and the final effects of what the function does. The inner workings are meant to be irrelevant.</p>
          <p>For example, here is an alternative greeting function:</p>
          <pre><code class="language-python">def cheerful_greeter_2(name):
          </code><code class="language-python indent">
            first_word = 'Hello, '
          </code><code class="language-python indent">
            print(first_word + name + '!')</code></pre>
          <p></p>
        </article>
        <article>
          <h1>The Return Keyword</h1>
          <p>Let's suppose that instead of printing out the cheerful greeting, I want to store it. So, given the name "Jean-Luc", the function would just compute the value</p>
          <blockquote><p><code class="snippet">Hello, Jean-Luc!</code></p></blockquote>
          <p>This function does just that:</p>
          <pre><code class="language-python">def greeting_maker(name):
          </code><code class="language-python indent">
            salutation = 'Hello'
          </code><code class="language-python indent">
            full_greeting = f'{salutation}, {name}!'</code></pre>
          <p>If we run this...</p>
          <pre><code class="language-python">greeting_maker('Jean-Luc')</code></pre>
          <p>... nothing seems to happen. That shouldn't be surprising, because although all the code has been executed, there is no <code class="snippet">print</code> statement to place the output on my screen.</p>
          <p>But suppose I want to be able to access that greeting so that I can use it elsewhere in my code? The greeting is stored inside the function in a variable called <code class="snippet">full_greeting</code> but, as we saw, variables within the function scope are not available to code outside the function. To make the computed value accessible, we use the <code class="snippet">return</code> keyword.</p>
          <p>Change the code to be the following:</p>
          <pre><code class="language-python">def greeting_maker(name):
          </code><code class="language-python indent">
            salutation = 'Hello'
          </code><code class="language-python indent">
            full_greeting = f'{salutation}, {name}!'
          </code><code class="language-python indent">
            return full_greeting</code></pre>
          <p>Now when we run the code in the REPL...</p>
          <pre><code class="language-python">greeting_maker('Jean-Luc')</code></pre>
          <p>... we see the cheerful greeting. This is an expression, computing a value. (The REPL takes care of showing it on the screen. In a standard Python program, we would not see the return value.)</p>
          <p>Note that the variable name <code class="snippet">full_greeting</code> is still hidden inside the function scope. If we try to access it, we will get a <code class="snippet">NameError</code>. So the usual thing is to assign the returned value to a new variable:</p>
          <pre><code class="language-python">hello_picard = greeting_maker('Jean-Luc')</code></pre>
          <p>Now we can do stuff with this result.</p>
          <pre><code class="language-python">print(hello_picard.upper())  # HELLO, JEAN-LUC!
          </code><code class="language-python">
            print(len(hello_picard))  # 16</code></pre>
          <p>The <code class="snippet">return</code> keyword stops function execution, so it is usually the last statement in a function. If it is not included, the function will return <code class="snippet">None</code> when its code has been executed. For example, if we try to treat our original <code class="snippet">cheerful_greeter</code> function as an expression...</p>
          <pre><code class="language-python">print(cheerful_greeter('Buster'))</code></pre>
          <p>... then we get:</p>
          <pre><code class="language-python">Hello, Buster!
          </code><code class="language-python">
          None</code></pre>
          <p>This is the expected output from the <code class="snippet">cheerful_greeter</code> code followed by the value returned - <code class="snippet">None</code> because no explicit <code class="snippet">return</code> was included.          </p>
        </article>
        <article>
          <h1>Summary</h1>
          <p>Functions are the building blocks of all Python code. You will be writing <i>lots</i> of them. They allow us to separate large applications into small, reusable sections. Because we only care about the function interface, we can change the implementation at will, which is very useful.</p>
          <p>You may be feeling a bit overwhelmed by this material, but don't worry, we will be going over this in much more detail during the course.</p>
          <p>For now, it's enough that you should:</p>
          <ul>
            <li>be able to declare a function using the <code class="snippet">def</code> keyword</li>
            <li>be able to write a function that takes parameters</li>
            <li>be able to invoke the function</li>
            <li>be able to use the <code class="snippet">return</code> keyword to get information out of a function
            </li>
          </ul>
        </article>
      </section>
      <section class="main-section" id="Lists">
        <header>Lists</header>
        <article>
          <p>We have already seen some of the basic data types available in Python. However, after you have been programming for a short time, it becomes clear that being restricted to these data types would severely hamper our ability to do useful things. Very soon, we will be able to deal with other, more complicated, data structures.</p>
          <p>Eventually, we will get around to designing our own data structures (using <b>object-oriented</b> programming techniques), but there are a few that come as standard with the Python language:</p>
          <ul>
            <li>lists</li>
            <li>dictionaries</li>
            <li>tuples</li>
            <li>sets</li>
          </ul>
          <p>They are all useful in different circumstances. We'll start with lists.</p>
          <h2>Storing multiple items</h2>
          <p>Consider a situation where we want to create variables that represent a <b>list</b> of data:</p>
          <pre><code class="language-python">item0 = 'apple'
          </code><code class="language-python">
            item1 = 'banana'
          </code><code class="language-python">
            item2 = 'strawberry'</code></pre>
          <p>We could continue to create variables in this way: however, we would have to keep declaring new variables every time we wanted to add something to this list. Instead, we can think of storing this data in a single <b>data structure</b></p>
          <h2>Lists</h2>
          <blockquote><p>A Python list is an <b>ordered collection of data.</b></p></blockquote>
          <h2>Declaring lists</h2>
          <p>Python lists are written using <code class="snippet">[</code> and <code class="snippet">]</code> with each item inside the square brackets separated by a comma. The list is stored in memory as an object, just like other data types, and can be assigned to a variable in the same way.</p>
          <pre><code class="language-python">items = ['apple', 'banana', 'strawberry']</code></pre>
          <p><code class="snippet">items</code> is a list containing 3 <b>elements</b>, an <b>element</b> being an item inside the list. The strings, <code class="snippet">"apple"</code>, <code class="snippet">"banana"</code> and <code class="snippet">"strawberry"</code> are said to be the <b>3 elements</b> making up the list <code class="snippet">items</code>. Using a plural variable name helps emphasise that this is a collection of data.</p>
          <h2>Zero indexing</h2>
          <p>Once we have declared the list, we can refer to its elements using the position they appear at. In computer science, <b>zero indexing</b> means that we start counting ordered collections from <b>zero</b>. All Python lists are <b>zero-indexed</b>. We can use the index position together with square bracket notation to access a list element at a specific position:</p>
          <pre><code class="language-python">letters = ['a', 'b', 'c']
          </code><code class="language-python">
            letters[0] # evaluates to 'a'
          </code><code class="language-python">
            letters[1] # evaluates to 'b'</code></pre>
          <p>A list cannot be accessed with a position that is bigger than the list length - an error will result:</p>
          <pre><code class="language-python">letters = ['a', 'b', 'c']
            # only 3 items
            </code><code class="language-python">
            letters[5] # causes IndexError</code></pre>
        </article>
        <article>
          <h1>The Length Property</h1>
          <p>All lists have a length property indicating the number of items present inside the list - we use the <code class="snippet">len</code> function to access this.</p>
          <pre><code class="language-python">items = ['apple', 'banana', 'strawberry']
          </code><code class="language-python">
          len(items) # will be 3</code></pre>
          <p>In many languages, lists and ordered collections of data have limitations on the amount of data they can store. In Python, the physical limitations of a list length are usually far beyond what will normally be needed.</p>
          <p>In addition, Python lists can hold items of multiple data types, which makes them extremely flexible data structures. The length property of a list will be updated when the list contents are altered. Python lists are said to be <b>mutable</b> as we can update their contents over time.</p>
          <pre><code class="language-python">items.append('kiwi') # this will add "kiwi" onto the end of the list, at index position 3
          </code><code class="language-python">
            items # returns ['apple', 'banana', 'strawberry', 'kiwi']
          </code><code class="language-python">
            len(items) # will now be 4</code></pre>
          <p>Note that the idea of mutability is different from what happens when we reassign a variable. Remember before, when we changed a simple variable:</p>
          <pre><code class="language-python">greeting = 'hello'</code></pre>
          <p>and then:</p>
          <pre><code class="language-python">greeting = 'howdy'</code></pre>
          <p>In that case, we changed the memory location that the variable pointed to. In this case, we can change the content of the list but leave its memory location unchanged.</p>
          <pre><code class="language-python">vegetables = ['cabbage', 'carrot', 'celery']
          </code><code class="language-python">
            id(vegetables) # returns some address eg 4314611264
          </code><br><code class="language-python">
            vegetables.append('cauliflower')
          </code><code class="language-python">
            vegetables # returns ['cabbage', 'carrot', 'celery', 'cauliflower']
          </code><code class="language-python">
            id(vegetables) # returns 4314611264 (unchanged)</code></pre>
          <p>The trick of reassigning a list variable still works and will change the memory address:</p>
          <pre><code class="language-python">vegetables = ['broccoli', 'beans', 'brussels sprouts']
          </code><code class="language-python">
            id(vegetables) # will return a different address eg 4314629056</code></pre>
        </article>
        <article>
          <h1>Slicing</h1>
          <p>As well as retrieving individual elements, we can retrieve elements between 2 indexes as well. Getting a sub-list is referred to as <code class="snippet">slicing</code>, as in we take a slice of the original list.</p>
          <p>The syntax for creating a slice is to use 2 indexes separated by a colon: <code class="snippet">[startIndex: endIndex]</code></p>
          <ul>
            <li>The first index is where to start slicing from and is <b>inclusive</b></li>
            <li>The second index is where to stop slicing and is <b>exclusive</b>
            </li>
          </ul>
          <p>So <code class="snippet">my_list[1:3]</code> would include the elements at indexes 1 and 2.</p>
          <pre><code class="language-python">letters = ['a', 'b', 'c', 'd', 'e']
          </code><br><code class="language-python">
            letters[1:3] # ['b', 'c']</code></pre>
          <p>When creating a slice, it is important to note that this creates a new list and the original list is left unchanged.</p>
          <pre><code class="language-python">letters = ['a', 'b', 'c', 'd', 'e']
          </code><br><code class="language-python">
            letters[2:3] # ['c']
          </code><code class="language-python">
            letters[1:5] # ['b', 'c', 'd', 'e']
          </code><code class="language-python">
            letters # ['a', 'b', 'c', 'd', 'e']
          </code><br><code class="language-python">
            letters[0:-1] # ['a', 'b', 'c', 'd'] negative indexes can be used as well</code></pre>
          <p>It is worth noting that both of the indexes are optional and can be omitted. If you omit one or both index they will use their default values:</p>
          <ul>
            <li><i>startIndex</i> - defaults to 0, i.e. starting at the first element</li>
            <li><i>endIndex</i> - defaults to the length of the list, i.e. stopping at the last element</li>
          </ul>
          <pre><code class="language-python">all_but_first	= letters[1:] # ['b', 'c', 'd', 'e']
          </code><br><code class="language-python">
            all_but_last	= letters[:-1] # ['a', 'b', 'c', 'd']</code></pre>
        </article>
        <article>
          <h1>List Methods</h1>
          <p>We will frequently want to update lists by adding or removing items.</p>
          <p>Python lists come with some built-in methods (i.e. code features) that can be chained onto lists themselves:</p>
          <p><code class="snippet">.append()</code> is a <b>mutating list method</b>. It will mutate a list by adding an item to the end of a list.
          </p>
          <pre><code class="language-python">letters = ['a', 'b', 'c']
          </code><code class="language-python">
            letters.append('d')
          </code><code class="language-python">
            # letters is now ["a", "b", "c", "d"]</code></pre>
          <p><code class="snippet">.pop()</code> is a <p>mutating list method</p> that acts by removing an item from the specified position, or the end if no position is specified. It returns the value of the removed item and leaves the original list changed.</p>
          <pre><code class="language-python">letters = ['a', 'b', 'c', 'd']
          </code><code class="language-python">
            last_letter = letters.pop() # last_letter is now 'd'
            # letters is now ['a', 'b', 'c']
          </code><code class="language-python">
            removed_letter = letters.pop(1) # removed_letter is 'b'
            # letters is now ['a', 'c']</code></pre>
          <p>There are many more methods listed in the <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">Python documentation.</a></p>
        </article>
        <article>
          <h1>Nested lists</h1>
          <p>Note that lists can contain any kind of Python object...</p>
          <pre><code class="language-python">crazy_list = ['alice', 2, True, 67.87, None, 'dave']</code></pre>
          <p>... including other lists:</p>
          <pre><code class="language-python">crazier_list = ['betty', 19, False, 0.000267, None, crazy_list]</code></pre>
          <p>Lists can also be constructed entirely from other lists. For example:</p>
          <pre><code class="language-python">best_trilogies = [
          </code><code class="language-python">
            ['fellowship', 'twin towers', 'return of the king'],
          </code><code class="language-python">
            ['a new hope', 'empire strikes back', 'return of the jedi'],
          </code><code class="language-python">
            ['godfather I', 'godfather II', 'godfather III']
          </code><code class="language-python">
          ]</code></pre>
          <p>Now, each item is itself a list:</p>
          <pre><code class="language-python">best_trilogies[1] # ['a new hope', 'empire strikes back', 'return of the jedi']</code></pre>
          <p>We can access members of this list by continuing to use square brackets:</p>
          <pre><code class="language-python">best_trilogies[1][0] # 'a new hope'</code></pre>
          <p>The first set of square brackets is evaluated first. We can see what that evaluates to by printing it</p>
          <pre><code class="language-python">best_trilogies[1] # ['a new hope', 'empire strikes back', 'return of the jedi']</code></pre>
          <p>Once this is done the second set of square brackets is evaluated, giving us index 0 from the <code class="snippet">['a new hope', 'empire strikes back', 'return of the jedi']</code> list. This results in the whole expression evaluating to <code class="snippet">'a new hope'</code>.</p>
        </article>
        <article>
          <h1>Exercises</h1>
          <p>For this section, you'll be completing some exercises on lists in the <a href="https://github.com/dalebar/python-practice">de-precourse repo</a> that you forked and cloned previously.</p>
          <p>Work through the exercises in <code class="snippet">02_lists</code> and complete each function.</p>
          <p>Use the notes in this lesson as well as the documentation. Don't feel restricted to the methods we've covered so far, and do your own research trying out new methods you find.</p>
          <p>Once you've completed the exercises you can move on.</p>
        </article>
        <article>
          <h1>Summary</h1>
          <ul>
            <li>Python lists are for collecting a number of data items in a particular order.</li>
            <li>Lists are declared with square brackets <code class="snippet">[...]</code> and items can be accessed using a zero-based index.</li>
            <li>Numerous list methods can be accessed using dot notation.</li>
          </ul>
        </article>
      </section>
      <section class="main-section" id="Dictionaries">
        <header>Dictionaries</header>
        <article>
        <h2>Dictionaries</h2>
        <p>Lists are ordered collections of data we can use for storing collections of items, but there are limitations to this data structure when it comes to organising data:</p>
        <pre><code class="language-python">details = ['Patricia', 'Lloyd', 55, 'St Marys', 'Leigh', 'Bolton'];</code></pre>
        <h2>Storing named data items</h2>
        <p>The list <code class="snippet">details</code> stores several values representing different details about a particular person. However, it becomes increasingly difficult to work out what the data represents, as the only way of accessing items is by their index position.</p>
        <p>We could instead use a Python <b>dictionary</b> to store the data values. A dictionary is a collection of key-value pairs called <b>properties</b>. Here is the same data provided as a dictionary:</p>
        <pre><code class="language-python">details = {
        </code><code class="language-python indent">
          'first_name': 'Patricia',
        </code><code class="language-python indent">
          'last_name': 'Lloyd',
        </code><code class="language-python indent">
          'age': 55,
        </code><code class="language-python indent">
          'place_of_work': 'St Marys',
        </code><code class="language-python indent">
          'regional_office': 'Leigh',
        </code><code class="language-python indent">
          'alternative_location': 'Bolton'
        </code><code class="language-python">
        }</code></pre>
        <p>The <b>keys</b> (values to the left of the colons) allowed us to store our data values by a known label, making it much more intuitive for us to see what the data represents.</p>
        <h2>Accessing dictionaries</h2>
        <p>The name "dictionary" suggests a process of "looking up" or accessing property values using a property key. Suppose we have a dictionary with two properties, <code class="snippet">name</code> and <code class="snippet">age</code>:</p>
        <pre><code class="language-python">person = {
        </code><code class="language-python indent">
          'name': 'Anat',
        </code><code class="language-python indent">
          'age': 24,
        </code><code class="language-python">
        }</code></pre>
        <p>We can access the property value <code class="snippet">"Anat"</code> by accessing the dictionary with a property key using square bracket notation:</p>
        <pre><code class="language-python">person['name'] # evaluates to "Anat"</code></pre>
        <p>If a dictionary is accessed with a key that is not present inside a dictionary, then this will result in a <code class="snippet">KeyError</code>.</p>
        <pre><code class="language-python">person['job'] # KeyError: 'job'</code></pre>
        <p>To avoid a <code class="snippet">KeyError</code>, you can use the <code class="snippet">get</code> method, providing a default value:</p>
        <pre><code class="language-python">person.get('job', 'General Assistant')</code></pre>
        <p>The keys do not have to be strings. The exact criteria for what can be a key are a bit complicated, but as a guide, avoid using a list or another dictionary. Otherwise, most things will be fine. The only other rule is that keys should be unique within the dictionary - no duplicates are allowed.</p>
        <h2>Ordering</h2>
        <p>As of Python version 3.7, dictionaries are ordered. They are organised by insertion order. This means if you were to loop over the dictionary, you would get the keys back in the same order that they were inserted.</p>
        <p>We can see this order by called the <code class="snippet">list() </code>function on a dictionary. This will return a list of all the keys, in insertion order.</p>
        <pre><code class="language-python">person = {
        </code><code class="language-python indent">
          'name': 'Anat',
        </code><code class="language-python indent">
          'age': 24,
        </code><code class="language-python">
        }
      </code><br><code class="language-python">
        list(person) # ['name', 'age']</code></pre>
        <p>This was not always the case, and in older versions of Python the order that keys are accessed could not be relied on so you may see this mentioned in older discussions about dictionaries.</p>
        </article>
        <article>
          <h2>Nested Dictionaries</h2>
          <p>Values can be any data type we like, including lists and other dictionaries.</p>
          <pre><code class="language-python">person = {
          </code><code class="language-python indent">
            'name': 'Paul',
          </code><code class="language-python indent">
            'favourites': {
          </code><code class="language-python double-indent">
                'author': 'Terry Pratchett',
          </code><code class="language-python double-indent">
                'band': 'Nightwish'
          </code><code class="language-python indent">
            },
          </code><code class="language-python indent">
            'interests': ['coding', 'running']
          </code><code class="language-python">
          }</code></pre>
          <p>Just as with lists, we can access nested values by chaining square brackets together.</p>
          <pre><code class="language-python">person['favourites']['author'] # 'Terry Pratchett' 
          </code><code class="language-python">
            person['interests'][1] # 'running' </code></pre>
          <p>Note that <code class="snippet">person['interests']</code> evaluates to a list, so we can then treat it as any other list and access an index using a number.</p>
          <h2>Complex example</h2>
          <p>This is the same for any values or levels of nesting. For example, this is a valid dictionary:</p>
          <pre><code class="language-python">mad_dict = {
          </code><code class="language-python indent">
            'alice': 'pears',
          </code><code class="language-python indent">
            17: [1, 2, 3],
          </code><code class="language-python indent">
            3.14: """nearly
          </code><code class="language-python double-indent">
                    pi""",
          </code><code class="language-python indent">          
            True: False,
          </code><code class="language-python indent">
            print: "hello world", # The key here is the built-in print function
          </code><code class="language-python indent">
            "The key doesn't have to be reasonable. It could be totally ridiculous": {'and': 'this', 'is': 'a', "nested": ["dictionary", "as", "value"]}
          </code><code class="language-python">
          }
          </code></pre>
          <p>We can recover all of these values:</p>
          <pre><code class="language-python">mad_dict['alice'] # pears
          </code><code class="language-python">
            mad_dict[17] # [1, 2, 3] (a list)
          </code><code class="language-python">
            mad_dict[17][1] # 2 (element 1 from the list)
          </code><code class="language-python">
            mad_dict[3.14] # 'nearly\n            pi' use the print command to see it print across two lines
          </code><code class="language-python">
            mad_dict[True] # False
          </code><code class="language-python">
            mad_dict[print] # hello world
          </code><code class="language-python">
            mad_dict["The key doesn't have to be reasonable. It could be totally ridiculous"]
            # {'and': 'this', 'is': 'a', 'nested': ['dictionary', 'as', 'value']}
          </code><code class="language-python">
            mad_dict["The key doesn't have to be reasonable. It could be totally ridiculous"]['nested'][0]
            # 'dictionary' - can you explain why?</code></pre>
        </article>
        <article>
          <h2>Dynamic Keys</h2>
          <p>When accessing or creating keys for our objects, we have been using literal values, such as strings or numbers. We can also use variables that contain those values in a similar manner.</p>
          <p>Here we have a dictionary with 2 keys and a variable that contains the string 'age'.</p>
          <pre><code class="language-python">
            person = {
          </code><code class="language-python indent">
              'name': 'Anat',
          </code><code class="language-python indent">
              'age': 24,
          </code><code class="language-python">
          }
          </code><br><code class="language-python">
          key = 'age'
          </code></pre>
          <p>We can access the person's age by using the key directly:</p>
          <pre><code class="language-python">person['age'] # 24</code></pre>
          <p>We can also use the variable to achieve the same result:</p>
          <pre><code class="language-python">person[key]   # 24</code></pre>
          <p>This works by Python evaluating the expression inside the square brackets. In this case, the key variable is evaluated to the string of 'age' and is used to access the key of that value. This means that we can programmatically access keys depending on the value of the variable.</p>
          <pre><code class="language-python">key = 'name'
          </code><code class="language-python">
            person[key] # 'Anat'</code></pre>
          <p>Note the variable name of <code class="snippet">key</code> is not relevant - this would work with any variable. However, it's good practice to name variables after what they represent.</p>
          <h2>Assigning keys</h2>
          <p>We can also do the same thing when assigning values to keys:</p>
          <pre><code class="language-python">person = {
          </code><code class="language-python indent">
            'name': 'Anat',
          </code><code class="language-python indent">
            'age': 24,
          </code><code class="language-python">
          }
        </code><br><code class="language-python">
        snack_type = 'biscuit'
        </code><code class="language-python">
        fav_snack = 'custard cream'
        </code><br><code class="language-python">
        person[snack_type] = fav_snack
        </code><br><code class="language-python">
        print(person) # {'name': 'Anat', 'age': 24, 'biscuit': 'custard cream'}</code></pre>
          <p>This also works when creating new dictionaries:</p>
          <pre><code class="language-python">
            snacks = {
          </code><code class="language-python indent">
              'drink': 'tea',
          </code><code class="language-python indent">
              snack_type : fav_snack
          </code><code class="language-python">
          }
          </code><br><code class="language-python">
          print(snacks) # {'drink': 'tea', 'biscuit': 'custard cream'}
          </code></pre>
        </article>
        <article>
          <h2>Exercises</h2>
          <p>For this section, you'll be completing some exercises on dictionaries in the <a href="https://github.com/dalebar/python-practice">de-precourse repo</a> that you forked and cloned previously.</p>
          <p>Work through the exercises in <code class="snippet">03_dictionaries</code> and complete each function.</p>
          <p>Use the notes in this lesson as well as the documentation. Don't feel restricted to the methods we've covered so far, and do your own research trying out new methods you find.</p>
          <p>Once you've completed the exercises you can move on.</p>
        </article>
        <article>
          <h2>Summary</h2>
          <ul>
            <li>Dictionaries are a handy way of collecting data with a label, indicating what each data item is.</li>
            <li>The label is called a <b>key</b>, the data item is called a <b>value</b>.</li>
            <li>Declare a dictionary with curly brackets, separating <code class="snippet">key:value</code> pairs with commas.</li>
            <li>Access dictionary items with square bracket notation referencing the key.</li>
          </ul>
          <p>You will find more details about dictionaries in the <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">Python Dictionary documentation</a>.
          </p>  
        </article>
      </section>
      <section class="main-section"id="Branching_and_Logic">
        <header>Branching and Logic</header>
        <article>
          <h2>Branching and Conditional Logic</h2>
        </article>
        <article>
          <h2>Truthy and Falsy Values</h2>
        </article>
        <article>
          <h2>Comparison and Logical Operators</h2>
        </article>
        <article>
          <h2>Logical Operators</h2>
        </article>
        <article>
          <h2>Additional If Syntax</h2>
        </article>
        <article>
          <h2>Conditional Expressions</h2>
        </article>
        <article>
          <h2>Summary</h2>
        </article>
      </section>
      <section class="main-section" id="Iteration">
        <header>Iteration</header>
        <article>
          <h2>For Loops</h2>
        </article>
        <article>
          <h2>Iterable Objects</h2>
        </article>
        <article>
          <h2>Conditional Iteration</h2>
        </article>
        <article>
          <h2>Summary</h2>
        </article>
      </section>
      <section class="main-section" id="Exercises">
        <header>Exercises</header>
        <article>
          <h2>Advanced Exercises</h2>
        </article>
        <article>
          <h2>Debugging</h2>
        </article>
        <article>
          <h2>Refactoring</h2>
        </article>
        <article>
          <h2>Summary</h2>
        </article>
      </section>
      <section class="main-section" id="Reference">
        <header>Reference</header>
        <article>
          <ul>
            <li>
              All the documentation in this page is taken from
              <a href="https://northcoders.com/" target="_blank">Northcoders</a>
            </li>
          </ul>
        </article>
      </section>
    </main>
    <script src="./prism.js"></script>
  </body>
</html>